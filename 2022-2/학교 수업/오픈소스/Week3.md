```toc

```

## Shell

### Terminology 
- 디스크는 두가지 큰 파일로 구분할 수 있다.
	- 커널 / 유틸리티
		- 커널
			- 운영 체제에 핵심적인 코드 프로그램
			- 부팅될 때 가장 먼저 메모리에 로드 됨
			- 컴퓨터가 꺼질때 까지 메모리상에 존재함
		- 유틸리티
			- 일반적으로 사용하는 프로그램
			- 소스코드를 컴파일 하면 바이너리 형태의 실행파일이 존재하게 된다.
- 유틸리티 중에서 쉘이 존재한다.
	- 다른 유틸리티들을 관리하기 위한 유틸리티이다.
	- 리눅스에서는 대부분 bash를 사용한다.
	- shell도 일반적으로 로그인할 때 올라온다.
		- 실행하면 ./a.out이라는 command line을 쉘 프로그램의 입력으로 전달한다.
			- 쉘프로그램이 fork라는 과정을 통해 프로세스를 만들어 디스크의 프로그램을 메모리에 올리게 된다.
		- 사용자로부터 입력된 명령어를 읽고 입력된 커맨드들을 해석하여 다른 유틸리티를 실행한다.
			- 쉘은 운영 체제의 핵심적인 시스템 콜이라는 함수를 이용하여 다른 유틸리티를 컨트롤하는 중간 다리 역할을 한다.

- 다음과 같은 순서로 발전해왔다
	1. Bourne Shell : sh
		- 최초의 default shell
		- 벨 연구소의 본이라는 사람이 만듬
	2. C Shell : csh / tcsh
		- C와 비슷하게 생김
	3. Korn Shell : ksh
		- vi 만든 사람이 만듬
	4. Bourne again Shell : bash
		- GNU 기반 쉘
		- 대부분의 리눅스 배포판의 기본 쉘로 사용됨.

### Bash
- 로그인이 된 후, 리눅스 / 유닉스는 Bash를 시작함.
	- bash는 대부분의 리눅스 배포판의 기본 쉘로 탑재됨
	- 이후, 사용자에게 커맨드를 대기 받는다.

## Advantages and Disadvantages
- 쉘 프로그램의 장점
	- 기존의 유틸리티들을 조합하여 빠르게 프로토타입으로 만들 수 있다.
	- 자동화에 용이하다.
	- 이질적인 코드들을 사용하는데 활용할 수 있다. 
		- 시스템에 사용되는 여러가지 다른 프로그램들에 대해 glue code로서 동작할 수 있다.
- 단점
	- 느리다.
		- 불필요하게 새로운 프로세스 만들거나 만들어진 프로세스와 통신하기 위한 오버헤드가 발생한다.
		- 복잡하거나 성능이 중요한 프로그램을 위해서는 사용하기 어렵다.
	- 컴파일 기반 문법이 아니기 때문에 잘못 작성된 코드가 실행되기 쉽다.
		- ex) rm -rf test \*와 rm -rf test\*는 전혀 다른 코드인데, 둘 다 실행된다. 
		- 물론 다르게 동작한다.

### Shell Variables
- 리눅스 유틸리티들에서 쉘에 필요한 정보들이 있을 수 있다.
	- 현재 경로 / 커맨드를 찾을 경로들의 집합 / 홈 디렉토리 등 시스템이 미리 정한 변수를 shell에 저장할 수 있다.
	- 프로그램의 실행에 필요한 정보들의 집합을 shell variables라 한다.
	- 이름과 값의 쌍으로 정의되고, 자유롭게 정의하고 사용하며 해제할 수 있다.

#### Environment Variables
- 쉘 변수 중 자식에게 되물림되는 변수
	- 자식 프로세스에게 전달될 수 있다.
	- 부모 프로세스로부터 카피될 수 있는 쉘 변수들
- 어떤 프로그램을 리눅스 쉘로 실행시키면, 쉘 프로그램이 부모 프로세스가 되는 것이고 실행한 프로그램이 자식 프로세스가 된다.
	- 부모 프로세스의 쉘 프로세스에서 환경변수만 카피해 전달된다.
	- 부모 프로세스로 받은 환경 변수를 수정하게 되면 부모 프로세스에는 영향을 끼치지 않는다.
		- 또 다른 자식 프로세스들에는 영향을 끼칠 수 있다.

##### Built-in Environment Variables
- 미리 정의된 환경 변수들이 존재한다. (PATH / HOME / PWD 등 필요에 의해서 정의됨)
	- 내장 환경 변수라고 한다.
	- 관습적으로 대문자로 표기된다.
- 환경 변수가 아닌 변수들을 local variable이라고 한다.

#### Set
- 쉘 변수는 처음 할당할 때 만들어진다.
- 다음과 같이 생성할 수 있다.
	```shell
	varname = value
	```
	- 생성할 때 공백 문자를 넣으면 안된다. 주의
	- C 프로그램과 같이 대소문자를 구분한다.
- 기본적으로 타입이 정의되어 있지 않고, 데이터를 문자열로 취급한다.
	- 이를 untyped script라고 한다.
- 가장 간단하게 확인하는 방법은 다음과 같다.
	```bash
	echo $varname
	```
- set 명령어를 사용하여 모든 쉘 변수를 확인할 수 있다.
- 예제 ![[Pasted image 20220920144041.png]]
#### Unset
- unset 명령어를 이용하여 환경변수를 지울 수 있다.
	```bash
	unset varname
```

#### export / env
- 일반 쉘 변수들을 export를 통해 환경 변수로 만들 수 있다
	``` bash
	export varname=value
```
- env 명령어를 통해 환경 변수들을 출력할 수 있다.
	```bash
	env
```
- 환경 변수에서 일반 쉘 변수로 바꿀 수도 있고, 일반 쉘 변수에서 환경 변수로도 바꿀 수 있다.
- 환경 변수는 자식 프로세스에도 영향을 미칠 수 있다.
	- 다음과 같이 여러개의 쉘에서 변수를 선언했을 때, 환경 변수와 일반 환경 변수인 no2만 전달되는 것을 확인할 수 있다.
- -n 옵션을 통해 환경 변수를 일반 쉘 변수로 바꿀 수 있다.
	```bash
	export -n $no2
```
	- 다음과 같이 환경 변수를 일반 변수로 전환할 수 있다.

#### example - make
![[Pasted image 20220920145824.png]]
- make 파일은 다음과 같이 만들어진다.

#### Built-in environment variables
- 리눅스가 미리 정의한 환경 변수들
	- env 실행했을 때 우리가 설정 안했는데 만들어져 있는 변수들이 있다.
	- 관습에 의해 모든 변수들이 대문자로 설정되어 있다.
- 다음과 같은 환경 변수들이 기본으로 설정된다.
	- HOME : 홈 디렉토리
	- PATH : PATH 세팅
		- 쉘에서 명령어를 입력하게 될 때 명령어를 찾는 디렉토리 정보를 제공한다.
			- 명령어를 찾는 디렉토리들의 리스트이다.
			- 콜론 (:)을 기준으로 정보를 가지고 있는다.
			- 환경변수를 임의로 바꾸게 되면, 명령어들을 찾을 수 없게 된다.
		- 새로운 명령어를 추가할 때 뒤로 추가하는 것이 일반적이다.
	- PWD : 현재 작업중인 디렉토리
	- BASH : 쉘 이름
	- OSTYPE : 운영 체제