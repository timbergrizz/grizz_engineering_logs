# Redirection and Pipe
## Linux Commands
- 다음 명령어를 통해 실행할 수 있는 모든 프로그램을 알아볼 수 있다.
	``` bash
	compgen -c # 바로 실행될 수 있는 프로그램
	compgen -a # alias
	compgen -A function # function
	compgen -b # built-in
```
	- 리눅스 커맨드는 alias, function, built-in, external 4가지로 구분될 수 있다.
	
### Alias
- 어떤 커맨드에 별칭을 부여하는 방법
- 다음을 통해 커맨드에 등록된 alias를 확인하고, 등록하고, 제거할 수 있다.
	```bash
	alias
	alias cdvoy="dir" # alias 새롭게 설정
	unalias cdvoy # alias 제거
```
- 기존의 커맨드를 바탕으로 새로운 커맨드로 확장해서 사용할 수 있다.
- single / double quote중 single이 더 strong하고, 이를 주로 사용하게 된다.
	- alias할때는 single이 낫다.
	
### Shell Function
- 기능이 반복적으로 사용될 것 같을 때 함수로 만들게 된다.
- command들을 그룹화 하여, 다른 사람들이 보기 좋도록 만드는 것이다.
	- function도 마찬가지로 define이 되어야 하고, 일반 커맨드처럼 사용할 수 있다.
- bash에서 function을 다음과 같이 만들 수 있다.
	![[A3CDAB9E-859D-4D90-AB5D-413BA754797D 1.jpeg]]
	- 괄호 내에 공백 넣어주어야 한다.
	- 이름만 커맨드처럼 사용하면 된다.
	- multiline으로도 선언할 수 있다.
		- 한 줄로 할땐 명령 끝에 ; 삽입하지만, 여러개의 라인에선 삽입하지 않아도 된다.
		
#### Positional Parameter
- 함수에서 파라미터를 따로 선언할 필요 없이 파라미터를 순서대로 적어주면 되다.
	- $(번호)로 적어 파라미터를 사용할 수 있다.
	![[AECF9E19-1C39-4136-8492-CC7142AFAC7A 1.jpeg]]

- shell function에서 positional parameter로 전달된다.

#### Return in Functions
- 대부분의 경우 커맨드에 대해 반환이 필요할 수 있다.
	- 반환은 scope로 한정시키는 것이다.
	- $? : 직전 커맨드의 종료 상태 값, status를 가져온다.
		- 윈도우든 리눅스든 동일하게 작동한다.
- return도 일종의 built-in command이다.

#### Exit Status
- 프로세스는 exit statue를 반환한다
	- 0이면 정상이고, 0이 아니면 에러가 발생한 것인다.
	- N이라는 fatal signal이 발생하면, 128 + N으로 반환된다.
- 모든 리눅스 / 유닉스 프로그램은 부모 프로세스에 integer code를 반환한다.
	- 리턴값이 0이면, 결과가 성공적인 것이다.
	- 리턴값이 1이면, 결과값이 실패한 것이다.
- 핵십은, special parameter를 $?를 통해 학인할 수 있다는 것이다.

#### A Simple Shell
- Shell function도 하나의 쉘로 작동할 수 있다.
- built-in command도 bash 내부의 함수이다.
	- 자주 사용되는 것들이 함수로 선언되게 된다.
- fork에 주목해야 한다.
	- 시스템에서 제공하는 함수인 시스템 콜
	- 프로세스를 복제하는 함수.
	- 한 번 호출하면 두번 리턴한다. 프로세스가 두개로 만들어졌기 때문이다.
	- 두개를 리턴할 때 한번은 0으로, 한번은 생성된 프로세스의 PID로 리턴한다.
		- return이 0이면 child, return이 pid면 parent가 된다.
	- &는 프로세스를 백그라운드에 실행한다는 신호이다.
		- 있으면 바로 다른 명령어 실행하고, 없으면 프로세스가 종료될 떄 까지 기다린다.

### Built-in Commands
- fork-exec을 하지 않는다.
	- shell에 존재하면 바로 실행을 한다.
	- 다른 pid를 갖지 않는다.
- 자주 사용되는 것을 built-in command로 구현하여야 한다.
	- system의 상태를 바꿀 수 있는 명령어는 빌트인으로 구성되어야 한다.- 
		- ex) cd : 대표적으로 bash의 pwd 상태를 현재 디렉토리로 바꾼다.
		- 상태를 바꾸는 커맨드를 external로 바꾸게 되면 변화가 반영이 되지 않게 된다.

### External Commands
- bash 기준으로 밖에 있는 커맨드들
	- forc-exec을 통해 실행하게 된다.
	- 쉘에서는 동일하게 &있으면 백그라운드에서 실행하여 기다리지 않고, 없으면 기다린다.
- 실행되는 우선 순위가 존재한다.
	- alias > shell fuction > built-in commands > external commands
- 쉘에서 다양한 옵션이 있고 이를 활성화 할 수도, 비활성화 할 수도 있다.

### Type
- 명령어의 type들을 알 수 있다.
- 명령어의 context까지 확인할 수 있다.

### Background Job
- touch : 파일을 새로 만드는 명령어
- &는 부모 프로세스가 기다리고 있지 않고 다른 잡을 명시하게 된다.
- and를 주면 배그라운드 프로세스에 대해 처리할 수 있다.

#### Job Control
- suspend : 잡을 중단시키고, 이를 제어하여 새로 실행시키는 것

## Linux Command Lookup
	
## Command List and Conditional Command List

### Command List
- ; / & 를 통해 연결시킬 수 있다.
	- 단순한 연결은 영향을 미치지 않고, sequential하게 실행하기만 한다.
	- ;는 순차적으로, &는 비동기적으로 백그라운드에서 실행하게 된다.
- 두가지를 조합하여 새로운 command를 만들 수도 있다.
	- 다음과 같이 커맨드를 조절할 수 있다.
### Conditional Command List
- &&, ||를 이용해 조건적으로 명령어를 실행하도록 할 수 있다.
	- && :  전에 있던 명령어가 정상적으로 실행되었을 때만 후에 있는 명령어를 실행한다.
	- || : 전에 있는 명령어가 정상적으로 실행되지 않았을 때만 후에 있는 명령어를 실행한다.

### Command Group
- 괄호로 묶고 ;를 통해 구분하여 프로그램을 실행하게 되면 서브 쉘에서 실행되게 된다.
	- 자식 쉘에서만 변화가 반영되고, 기존 쉘에는 반영되지 않는다.

## File Descriptor
- open() 함수 또한 시스템 콜이다.
	- 파일이라는 포인터를 바탕으로 핸들링했다.
	- 내부적으로는 어떠한 값을 반환한다.
- read할 때 fd값이 인자로 들어간다.

- 파일은 2개의 블록으로 저장된다.
	- 메타데이터 
		- 파일에 대한 정보
		- 파일을 관리하기 위해서 이름, 식별자, 생성자, 접근 권한 등의 정보를 필요로 한다.
		- 실제 파일이 위치하는 위치 정보도 저장된다.
	- 컨텐츠
		- 실제 데이터
		- 용량에 따라 많은 블럭으로 구성되어 있을 수 있다.

- 파일은 멀티 유저를 지원한다.
	- 같은 파일을 다른 유저가 접근할 수 있다.
	- 메타데이터를 복제하는 것 보다 정보룰 공유할 수 있는 것이 효율적이고, 보안성으로도 유리하다.
- 모든 프로세스가 하나의 메타데이터를 공유하면 모두 같아야 하는데, 위치 정보가 다를 수 있다.
	- 리눅스에서는 메타 데이터를 이원화시킨다.
		- system-wide한 정보와 process별로 공유하지 않는 정보가 된다.
- 유닉스에서 file struct의 정보를 필요로 하고, 포인터가 나온다.
- 파일을 사용하다보면 프로세스에서 하나의 파일만 여는 것이 아닌, 여러개의 파일을 열 수 있다.
	- file struct가 계속 생기고, 포인터를 이용해 이를 핸들링 해야 한다.
	- 이를 한데 모아 테이블화 한것이 오픈 파일 테이블이다.
- file descripter는 결국 파일에 대한 정보가 담긴 테이블이라고 할 수 있다.
	- 프로세스마다 기본적으로 테이블이 존재하게 된다.
	- 파일을 생성할 때 마다 테이블에 정보가 추가되는 것이다.
- std[0] ~ std[2]는 예약되어 있다.
	- open / read / write로 표준 입출력도 핸들링하기 위해서 표준 입/출력도 여기서 정의되어 있다.
	- 0 -> stdin, 1 -> stdout, 2 -> stdexc

#### Open()
- open 함수를 실행했을 때, root도 하나의 파일이고 어떤 파일들이 있는지 정리하게 된다.
	- 경로에 존재하지 않으면 실패를 반환해야 하기 때문에, lookup을 수행한다.
	- rootdir에 대한 컨텐츠를 봐야 하고, dir의 컨텐츠는 디렉토리 안에 있는 파일들의 목록이다.
		- 리눅스에서는 파일 이름과 inode번호로 관리한다.
		- lookup 과정에서 방문한 디렉토리들을 내부 구조상으로 한번 사용하고 날리는 것이 아닌, file descriptor에 저장해둔다.
		- 0, 1, 2는 표준 입출력 / 에러로 할당해둔다.
#### Commands with Standard Input
- wc : 글자의 개수, 길이, 바이트 수를 센다
- sort : 컨텐츠를 줄별로 정리한다.
- bc : 기본적인 계산기를 제공한다.

## Redirection
### Standard Input Redirection
- 지정한 파일로부터 읽도록 한 후, 이를 stdin으로 집어넣는다.
	- 3개의 예시를 봤을 때, 기본적으로 사용자 입력을 기다린다.
	- 0<  (filename)을 통해 입력하면, standard input을 파일로 redirection한다는 뜻이 된다.
	- 0은 생략 가능하고 <로 작성할 수 있다.

### Standard Output Redirection
- 표준 출력을 파일로 리다이렉션한다.
	- 1>을 통해 파일로 저장할 수 있다.
	- 마지막 것만 본다는 것은 override된다는 것이다.
- >>를 통해 이미 존재하는 파일에 append할 수 있다.
- 이것도 마찬가지로 1 생략해도 상관 없다.

### Standard Error Redirection
- 2>를 통해 에러를 저장할 수 잇다.
	- >만 입력하면 파일로 저장되지 않는다.
- 2> >를 모두 사용할 수도 있고, 이룰 묶어서 사용하려면 &>를 이용하여 수행할 수 있다.
	- 2> >를 다르게 지정하면 서로 다른 파일에, &>는 같은 파일에 저장할 수 있도록 한다.

### More...
- /dev/null이라는 소각장이 있다.
	- 여기로 보내면 메시지 모두 버릴 수 있다.

### Combination of Redirections
- 입력 / 출력을 함께 사용할 수 있다.
	- 순서는 상관 없다.
	- cat < file1 > file2는 cp와 동일한 의미를 가진다.

## Pipe and Filter
### Pipe
- 왼쪽 명령어의 출력을 오른쪽 명령어의 입력으로 넣게 된다.
- |를 이용해 사용할 수 있다.

### Filter
- 파이프를 사용하려면 표준 입출력이어야만 한다.
	- 디렉토리 관리 등은 표준 출력이 없고, 따라서 파이프로 사용할 수 없다.
	- 출력이 없으면 파이프를 통해 연결할 수 없다.
- 표준 입출력 없이 파이프를 사용하는 것을 Filter라 한다.
	- 확장할 수 있는 중요한 도구가 된다.

### Cut, tr, and awk
-  리눅스에서 데이터 마무리할 때 자주 사용되는 명령어이다.

#### cut
- row -> cardinality / Column -> Field
- 표준 출력을 구분자를 바탕으로 자른다.
- 원하는 레코드와 필드를 지정하여 데이터를 지정할 수 있다.

#### tr
- 문자들을 변환하거나 삭제할 때 사용한다.
- tr "(찾는 문자열)" "(대체할 문자열)" 형태로 사용할 수 있다.
- tr -d 옵션을 통해 문자를 삭제할 수 있다.

#### awk
- cut은 필드 관리 등에서 확장성이 떨어질 수 있다.
- awk는 하나의 스크립트 언어로 결과값에 대해 특정한 결과를 얻어낼 수 있다.

- 인자는 크게 컬럼으로, 패턴과 액션으로 나눠진다.
	- 패턴은 일종의 액션이 수행되는 조건
	- 액션을 패턴이 참일때 수행하는 조건
	- 안에서 사용되는 약속된 변수가 있다.
		- 필드를 구분할 수 있도록 데이터에서 정해진 조건이 있다.
	- 프로그래밍처럼 조건에 맞게 출력을 하도록 설정할 수 있다.
- NF -> 필드의 수 / NR -> 레코드의 수
	- 이를 활용해 추가적인 조건을 부여할 수 있다.

동일한 기능을 제공하더라도 다른 언어를 필요로 할 수도 있다.
