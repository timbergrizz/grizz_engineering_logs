# TCP
- TCP의 모든 것을 설명하는 것은 아니고, 일부분만 설명하게 될 것이다.
- 반드시 복습을 하고 와야한다.
```toc
```

## TCP/IP Protocol Suite
![[Pasted image 20220912174627.png]]
- TCP는 Transport Layer에 존재한다.
	- TCP와 UDP가 일반적으로 사용된다.
	- 이 그림에서 크기가 클수록 비중을 크게 차지한다.
		- TCP가 하는 일이 훨씬 많고 복잡하다.
- 네트워크 레이어에는 여러가지 프로토콜들이 존재한다.
	- IP가 제일 큰 이유는 IP를 제일 많이 사용하기 때문이다.
- TCP가 하는 일 대부분을 UDP는 수행하지 않는다.
	- TCP를 이해할 수 있다면 UDP를 쉽게 이해할 수 있다.

## Ports
### Well-known Ports used by TCP
![[Pasted image 20220912174941.png]]
- 컴퓨터에서 인터넷을 사용하는 모든 프로세스는 번호를 부여받아야 통신이 가능하다.
	- 포트 번호를 알아야만 원하는 프로세스로 신호를 보낼 수 있다.
- 클라이언트가 서버로 접속하기 위해서는 IP주소, 포트 번호가 있어야 접속이 가능하다.
	- ip는 전화번호, 포트는 내선 번호라고 생각하면 된다.
- 일반적으로는 포트 번호를 자동으로 assign한다.
	- 0-1023까지는 이미 지정되어 있고, 1024번부터 시스템이 임의로 지정하게 된다.
	- 클라이언트에 사용되는 프로세스들은 시스템이 임의로 포트 번호를 지정하게 된다.
- 포트는 결국 프로세스들을 구분하기 위한 번호일 뿐이다.
- 클라이언트에서 서버로 접속할때는 반드시 알아야 하고, 프로그램 내부적으로는 일반적으로 지정되어 있을 것이다.
	- 하지만 반드시 지정되어 있어야 한다.

## Stream Delivery
![[Pasted image 20220912175723.png]]
- 바이트의 연속으로 이동하는 것 처럼 보일 수 있다.
- Stream Delivery
	- TCP와 반대인 UDP에서는 Boundary Delivery라고 하는 것이 사용된다.
		- 어플리케이션 입장에서 여러 어플리케이션의 데이터를 보낼 때 어플리케이션 단위를 한 패키지로 포장하여 보내게 된다.
			- 어플리케이션에서 만들어진 데이터를 전달할 때 유지가 되도록 해야 한다.
	- TCP는 데이터를 순차적으로 쌓아놓고 전송하게 된다.
		- 데이터를 만들어진 패키지로 보내는 것이 아닌, 보낼 수 있는 용량만큼 순차적으로 보내게 된다.
		- 따라서 Stream처럼 데이터가 이동하는 것처럼 보이게 된다
			- 여러 개의 패키지가 다른 것처럼 보일 수 있지만, 이를 구분하지 않고 필요한 만큼 끊어서 전송하게 된다.
			- 어플리케이션 단에서 지정한 가상의 바운더리가 TCP에서는 구분되지 않고 스트림 형식으로 데이터가 전송되게 된다.

	
![[Pasted image 20220912175739.png]]
- 어플리케이션에서 데이터를 전송할 때 이를 패키지로 받지 않고, char by char로 받는다.
	- 한 바이트씩 받아 buffer로 줄세워 놓고, 전송이 될 때는 buffer 단위로 전송된다.
	- 일반적으로 536바이트 단위로 전송되게 된다. 500~1000 사이로 존재한다.
- stream of delivery에 민감한 어플리케이션이 있을 수 있고, 평생 신경 안쓰고 프로그래밍 할 수도 있다.
	- 민감한 어플리케이션에는 왜 이렇게 작동하는지 이해할 수 있어야 한다.
- 다음과 같이 좀 더 자세히 그려질 수 있다.
	![[Pasted image 20220912180825.png]]
	- 수신자 송신자 모두 버퍼를 가지고 있다.
		- TCP는 양방향 통신이므로, 특정 서버에 있는 데이터를 요청을 하면 그 데이터를 반환해주는 방식으로 작동한다.
		- 지금 그림에서는 단방향으로만 그려져 있지만, 데이터는 원래 양방향으로 전송된다.
	- 송신자의 버퍼를 Sending Buffer, 수신자의 버퍼를 Receiving Buffer라 한다.
		- 한 프로세스에는 두개의 버퍼 모두 존재할 수 있어야 한다.
		- Sending Buffer에는 총 3가지 영역이 존재한다.
			- Sent : 이미 보낸 데이터가 저장되는 영역
				- 데이터가 전송되지 않았을 때 데이터를 다시 전송하기 위해 존재한다.
			- Not Sent : 아직 보내지 않은 데이터가 차지하는 영역
			- Empty : 데이터를 저장할 공간
		- Receiving Buffer에는 2가지 영역이 존재한다.
			- 네트워크에서 데이터가 들어오면 Empty 영역에 순차적으로 저장한다.
				- 저장된 데이터중 정상적인 데이터만 반환하게 된다.
		- 패킷 형태로 보내지게 되고, 이를 TCP에서는 Segment라 한다. 
	- 버퍼 영역은 커널단에서 존재하고, 어플리케이션에서는 이를 관리하지 않는다.
		- 그렇기 때문에 이를 직접 뜯어서 보는 것이 어렵다
- 어플리케이션에서 만든 가상의 바운더리가 전송될 때는 무시된다.
- 이 커넥션에서 반대로 가는 버퍼도 필요로 하지만, 이는 복잡도 문제로 생략된 것이다.


## Segment
- 각 connection에서 임의의 숫자로 패킷의 번호가 설정된다
	- 패킷이 정상적으로 전송되었는지 여부를 확인하기 위해서이다.
	![[Pasted image 20220912182119.png]]
	 - 이때 segment의 시작 바이트의 번호를 패킷에 쓰게 된다.
	 - 패킷에 부여하는 번호를 sequence number라 한다.
- 세그먼트의 sequence number field의 값은 세그먼트의 첫번째 데이터 바이트의 번호가 assign된다.

## Header
![[Pasted image 20220912182327.png]]
- 세그먼트의 헤더는 다음과 같이 구성된다.
	- 이 헤더에 Sequence Number를 부여한다
		- 도착을 보장하기 위해 데이터에 번호를 부여한다.
		- 시작은 랜덤이지만, 데이터의 순차적으로 부여된다.
		- 데이터의 바이트 크기 단위만큼 간격으로 부여되게 된다.
			- 데이터가 순차적으로 이동하지 않는다.
	- 바이트의 범위를 확인한 후 가장 앞 번호를 sequential number로 할당할 수 있다.

- 헤더와 데이터를 구분하는 경계선은 없다.
	- 이를 끊어서 읽을 수 있어야 한다.
	- 기본적으로 헤더는 20바이트고, 이를 끊어서 읽을 수 있어야 한다.
		- 경계를 상대방에게 알려줄 수 있다.
		- 옵션을 사용하면 40바이트까지 확장할 수 있다.
			- 이때 헤더를 어디까지인지 인식할 수 있어야 한다. 이를 명시하지 않으면 헤더가 어플리케이션으로 가게 된다.

- HLEN으로 경계를 표현한다.
	- 이때 4의 배수로 표현되기 때문에, 바이트를 아껴 0~15까지만 표현할 수 있으면 된다.
		- 따라서 60바이트까지 존재하지만 4비트를 할당하여 경계를 표현할 수 있다.
	- << 두번 해주면 원래 경계 알 수 있다.
	- 옵션을 비트에 딱딱 떨어지도록 설해뒀다.
- reserved는 어떻게 할당될 지 결정되지 않아서 그냥 냅둔 공간이다.

- application은 port번호를 필요로 하고, 따라서 src와 dest의 포트 번호를 처음에 할당하게 된다.
	- 이후 시퀀스 번호와 응답 시퀀스 번호가 순차적으로 온다.
- 32비트 -> 4바이트므로, 20바이트는 5개의 32비트로 표현되는 것이다.

### Acknowledgement
- acknowledge번호에는 데이터를 받았다는 의미가 함축되어 있다.
	- 데이터를 받은 후 필요한 정보를 반환하게 된다.
- 응답에는 2가지 방식이 있다
	![[9F6C1632-DEEF-4E22-B343-C11E8B67E805.jpeg]]
	- Selective ACK : 요청 번호와 응답 번호가 동일하다.
		- TCP에서는 이를 사용하지 않는다.
	- Cumulative ACK : 다음번에 받고 싶은 바이트 번호를 응답으로 보낸다.
		- 상대방은 응답으로 온 데이터 번호에 맞는 데이터를 다시 요청으로 보내면 된다.
		- TCP는 이와 같은 방식을 사용한다.
	- 서로 장단점이 존재하지만, TCP는 후자를 사용하게 된다.
- ack field의 값은 receiver가 다음번에 받을 바이트 번호로 알려주는 것이다.
	- 다음 바이트 번호를 의미하게 된다.

### Control Field
![[3AE5C7C1-AD60-407D-AA4F-68738F29AB72.jpeg]]
- 6비트로 할당되며, 각 비트의 의미를 이해해야 한다.
	- ack : ack을 전송할 때 명시하는 비트이다.
		- ack뿐 아니라 다른 용도로도 패킷이 가고, 따라서 이를 1로 설정하여 ack라는 것을 명시하는 것이다.
	- SYN : synchronize sequence numbers
		- 값을 확인하고 
	- FIN
		- 연결 종료 패킷
		- 헤더만 날아간다.
	- Urgent, Push, Rest은 잘 사용되지 않는다.

### Checksum
- 데이터가 전송중에 하드웨어적 오류로 데이터가 변질될 수 있다.
	- 잘못된 정보가 어플리케이션으로 입력되면 안된다.
- 오류를 검증하기 위해 존재하는 부분이다.
	- 어떤 부분의 오류인지는 확인할 수 있다.
![[2AB60182-F298-49C5-85CB-FE13FD0CB4FB.jpeg]]
- IP 헤더에서 Checksum은 비트를 일정 단위로 끊은 후 블락을 쌓고, 이를 complement로 취한다.
	- AND해서 0이 나오면 오류가 없는 것이고, 아니면 오류가 있는것이다.
	- IP에서는 헤더에 오류가 있는지 확인하기 위해 사용한다.
- 어플리케이션이 만드는 Message가 있고, 여기에 헤더가 붙어 TCP가 된다.
	- IP checksum은 헤더의 오류를 확인한다.
		- 메시지에 오류가 생기면 확인할 수 없다.
		- 여기서 오류가 확인되면, 데이터를 보내지 않는다.
	- TCP의 checksum이 전체 패킷을 확인한다.
		- 복수의 데이터에 오류가 발생해도 이를 잡아낼 수 있다.
- TCP의 checksum은 의무적이다.
	- UDP는 checksum이 의무적이지 않다.
- TCP는 헤더, 데이터, 그리고 pseudo에 있는 ip 정보까지 확인하게 된다.

## Encapsulation
![[0C927477-62FF-4E70-AC00-44D91AF310DB.jpeg]]
- Application에서 메시지를 만들고, 어플리케이션에 헤더가 없을 수도 있다.
	- HTTP는 헤더가 있고, 우리가 만든 실습 어플리케이션은 헤더가 없다.
- 어플리케이션에서 헤더를 뽑고, TCP에서 헤드를 붙여 세그먼트를 만든다.
	- 이를 네트워크 레이어에서는 IP헤더를 붙여 패킷을 만든다.
	- IP헤더에 보내는 / 받는 부분의 IP가 들어간다.
	- 이러한게 패키징 되어 프레임 헤더를 붙이고 데이터를 삽입한다.
	- 따라서 각 레이어 별로 전송하는 "데이터"의 의미가 달라지게 된다.
		- 이러한 데이터를 payload라 한다.


## 3-Way Handshake
### Connection Estabilishment
![[E706A2ED-A27A-44F6-9641-C1C36547E721.jpeg]]
- TCP는 데이터를 연결을 해야 한다.
	- TCP는 전화 / UDP는 엽서로 표현된다.
	- TCP는 상대방이 데이터를 수신한다는 확인이 있어야 데이터를 송수신 할 수 있지만, UDP는 받는 여부 상관 없이 그냥 무지성으로 데이터 뿌린다.
		- 수신을 확인하는 과정을 Setup이라 한다.
- TCP에서 setup은 다음과 같이 구성된다.
	- 클라이언트에서 연결 요청을 보낸다.
		- setup 필드를 1로 설정하여 연결 요청을 할 수 있다. 이때 포트를 명시해야 한다.
		- 이때 서버가 대기중이어야 연결이 이루어질 수 있다.
		- 시퀀스 넘버는 임의의 번호로 설정되어 전송된다.
	- 연결 요청이 가서 서버와 클라이언트의 연결이 성립되면, 서버에서 클라이언트로 연결 요청을 한다.
		- 일반적으로 승락된다. 시퀀스 넘버의 다음 번호를 ack num으로 주면 승락된다.
		- SYN + ACK 비트가 활성회되어 보내진다.
	- 이후 클라이언트에서도 서버의 요청에 대한 ACK을 보내고, Connection을 통한 데이터 전송이 진행되게 된다.
- 이러한 과정을 거쳐 TCP의 버퍼가 구성되게 된다.

![[00FB7FF7-EA3E-40DC-8F4C-695D465CC2A6.jpeg]]
 - bind등으로 포트를 지정해주어야 한다.
	- listen을 통해 데이터를 수용하도록 서버 소켓을 만들어야 한다.
	- accept는 패킷 들어올 때 까지만 기다린다.
	- connect 호출하면 SYN 호출된다.
- 다음과 같이도 handshake를 표현할 수도 있다.
	- 이 상태에서는 응답에 대한 응답이 없기 때문에, 응답이 갔는지 확인하지 않는다.
- 사진상의 글은 소켓의 함수들이다.
	- 클라이언트에선 socket 만들고, connect하는 것으로 구성된다.
		- connect 함수가 처음 호출되면 SYN이 전송된다.
	- 서버에선 socket, bind, listen, accept등이 구성된다.

- SYN은 상대방이 받았는지 확인하는 것으로, 중요하다.
	- SYN 패킷은 데이터 안보고 헤더만 본다.
		- 중요하니까 그냥 seq num 부여한거다.
	- SYN + ACK도 데이터 없는데 시퀀스 넘버 부여하는 것이다.
	- ACK은 데이터 없으면 seq num 할당받지 않는다.

- TCP 그림을 볼 때 한 그림에 모든 것을 담기 어렵다.
	- 생략이 많이 이루어지고, 잘 표현되지 않는 부분도 있다.
- 디자인할 땐 패킷 하나에 ACK하나를 보내도록 한다. 근데 원래 2개당 하나만 보내도 된다.
	- 이 사진에서 10000번까지는 제대로 받은 것이다.
	- 서버가 상대방에게 보낼 데이터가 있으먄, 데이터를 같이 보내면 된다.

### Connection Termination
![[F74595B1-85A9-4E8D-80C3-BCFFA4883CB9.jpeg]]
- 데이터 송수신이 완료된 후, 종료되어 버퍼를 시스템에 반환해야 한다.
- 종료 과정을 FIN 패킷이라 한다.
	- SYN이랑 SEQ랑 헷갈릴 수 있다. SYN은 연결 요청, SEQ는 패킷의 serial 번호이다.
	- FIN 패킷을 전송하면 종료를 요청하게 된다.
		- FIN + ACK패킷을 통해 전송 종료를 확인할 수 있다.
		- 이에 대한 ACK 패킷을 보내면서 데이터 송수신이 종료된다.
- 3-way로 종료되는 경우도 있지만, 서버의 프로그램을 어떻게 짜느냐에 따라 4-way로 종료될 수도 있다.
	- ACK와 FIN의 딜레이를 두어 두개의 패킷으로 따로 갈 수 있다,.
		- 일정 시간 내로 FIN이 설정되지 않으면 ACK과 FIN이 따로 가게 된다.
		- 서버에서 FIN은 close 함수가 실행될 때 닫힌다.
	- close가 들어오면 커넥션이 소멸되고, 커뮤니케이션을 위해 잡아둔 시스템 버퍼를 시스템에 반환한다.
- FIN은 데이터 가지 않고 헤더만 간다. seq num쓴다.
- FIN + ACK도 데이터 포함 안되어 있어도 seq num 사용한다.

#### Half-Close
![[A5CA3E0D-F0BA-4EFF-8FC0-7C21394828B7.jpeg]]
- FIN 있을 떄 까지 한 4-50 ms 기다리다가 전송한다.
![[55FEF188-CF22-4FBF-AA1B-F869C39CC131.jpeg]]
- 클라이언트가 서버에 종료 요청을 보냈을 때, 서버가 보낼 데이터가 더 있으면 연결을 끊지 않고 데이터를 보낸다.
	- 이러한 상황에서 Half-Close를 사용할 수 있다.
	- 보낼 데이터가 더 있을 경우 보내도 된다.
- Sending Buffer는 없어진다.
	- 클라이언트에서 서버로 가는 데이터는 없고, Receiving만 가능하다.
	- 신뢰성이 보장되어야 하므로 받은 데이터에 대한 응답은 계속 보내야 한다.
- 서버에서 FIN이 오면 ACK이 중단된다.
- 클라이언트가 서버로 종료했을 때, read로 데이터를 모아 온다.
	- 데이터가 없으면 가져올 때 까지 기다리고, 있으면 가져온다.
	- read될 때 return값은 data의 크기가 된다.
		- read return되면 데이터가 있는 것이다.
		- 일반적으로 리턴값이 1 이상이 되어야 한다.
	- 0으로 리턴되는 케이스는, 상대방이 Close해서 FIN을 보냈을 때이다.
		- 코드에서 항상 read의 return 값을 체크한다.
			- 0이 아니면 계속 통신하고 0이면 종료한다.

### State Transition Diagram
![[69FC8AA2-9632-4B5D-BA08-3279AD9F0F6C.jpeg]]

- 클라이언트는 연결 요청을 하고, 연결이 오기 전까지 기다려도 된다.
	- 서버 입장에서도 ack이 올때까지 기대려야 한다.
	- 그렇기 때문에 클라이언트와 서버가 상태를 가지고, 이러한 상황들을 state transition diagram으로 지정해 두었다.
- client의 흐름을 실선, server의 흐름을 점선으로 구성한다.
	- 클라이언트가 소켓을 연 순간을 SYN-SENT라 한다.
		- SYN-SENT에서 ACK이 오면 ACK을 보내주고, 이 상태를 ESTABLISHED라 한다.
		- close를 호출하면 FIN이 호출된다.
			- 이때 서버에서 ACK이 먼저 오면 FIN-WAIT 상태가 되고, FIN을 기다린다.
				- 이러한 상태를 TIME-WAIT 상태라 한다.
			- FIN이 같이 오면 ACK을 보내고 TIME-WAIT상태로 간다.
		- CLOSED상태가 되면 연결이 종료되는 것이다.
	- 서버는 연결이 들어올 때까지 LISTEN 상태로 대기하고 있는다.
		- 클라이언트로부터 SYN이 오면 SYN/ACK를 보내고 이 상태를 SYN-RCVD라 한다.
		- 다시 클라이언트로부터 ACK을 받게 되면 ESTABLISHED상태가 된다.
		- FIN을 받으면 ACK을 보낸다.
			- 상태는 CLOSE-WAIT 상태로 들어가는 것이다.
			- close 함수가 실행되면 fin이 전송되는 것이다.
- ESTABLISHED상태가 되면 버퍼가 만들어져 데이터를 보낼 수 있는 상태가 된 것이다.
	- 클라이언트는 ACK이후부터 데이터를 받을 수 있다.
	- 서버는 클라이언트로부터 ACK을 받을 때부터 데이터를 받을 수 있다
- read / write 순서는 달라질 수 있다.
	- 어플리케이션에 따라 달라질 수 있고, 가공하거나 다른 데이터를 찾아서 보내는 것은 시간이 더 오래 걸릴 수 있다.

- 연결의 성립 / 소멸과 상태를 다음과 같이 연결하여 볼 수 있다
![[75D036F4-AA7D-4F94-9E41-50942EF92623.jpeg]]

### TIME-WAIT
- Time-wait 상태
	- 클라이언트에서 종료하는 ACK이 없어진다고 해보나.
	- ACK에 대한 ACK이 없어 학인할 수 없다.
		- 서버에서 ACK이 안오면 데이터를 재전송한다.
			- 클라이언트에 time-wait이 없으면 ACK이 전송되지 않았을때 응답이 오지 않는다.
	- 그렇기 때문에 2MSL만큼 대기를 시키게 된다.
		- Maximum Segment Limit
		- 최대 시간의 2배만큼을 기다린다.
		- 한국 - 미국이 200ms정도 걸린다.
			- 거리마다 다르긴 한데 30초 - 1분 정도로 세팅한다.
			- 따라서 1-2분정도를 대기 상태로 둘 수 있다.
		- 아무일도 없으면 close보내고, 신호 다시 오면 ACK다시 보내고 TIME-WAIT으로 돌아간다.

- 다음 코드는 iterative server 코드이다.
	![[880ADC51-8379-4FD3-8692-FA13C3F6327F.jpeg]]
	- 5명의 클라이언트에 순차적에로 서비스를 제공한다.
		- 커넥션이 올 때 마다 빈 소켓으로 할당하여 보내게 된다.
		- 주어진 코드에서 2개의 소켓이 만들어지고, 
	- return되는게 있는데, 이게 새로운 소켓 번호고, 새로운 소켓 번호를 통해 읽기/쓰기를 수행한다.

![[C3232E74-AEE3-4A2A-8632-302B596789CF.jpeg]]
- 각각의 프로세스 / 쓰레드를 새로 만들어 여러개의 소켓을 만들었다고 하자.
	- 클라이언트가 요청을 보내면 새로운 소켓을 만들고, 클라이언트를 이 소켓에 할당한다. (3456)
	- 만약 클라이언트2가 연결 요청을 보내면 서버는 accept가 되고, 새로운 소켓을 생성하여 할당한다 (3457).
	- 다음과 같이 클라이언트가 접속될 때 마다 새로운 소켓을 만들어 할당하게 된다.
- 들어가는 포트는 모두 동일하고, 상대방이 보내는 포트와 ip 정보를 바탕으로 서버 내부적으로 소켓을 할당하여 해당하는 위치로 데이터를 전달하게 된다.
	- 데이터를 어떤 소켓으로 보낼지 ip와 포트 번호를 통해 결정하게 된다.
	- 한 포트를 쓰는 것만으로도 어떤 포트에서 오는 것이고, 어떠한 포트 번호로 오는지를 알 수 있다.
	- 하나의 어플리케이션으로도 다양한 클라이언트가 들어오기 때문에 다 확인해야 한다.

![[72BF53E5-AFDD-43FE-8CF1-9D1117D29D39.jpeg]]
- 특정 패킷이 라우팅 문제로 인해 늦게 서버로 도착했다고 가정하자.
	- TCP는 못받았다고 가정하고, 다시 보내게 된다.
		- 여기서는 정상적으로 데이터 송수신 끝냈다고 하자.
	- 근데 돌아다니던 패킷이 다시 연결되었을 때 들어갔다고 하자.
	- 우리가 쓰는것은 32비트짜리 seq 번호다.
		- seq번호가 비슷하면 꼬이기 시작한다.
		- 해당되는 곳에 쓰던 데이터를 할당하여 채운다.
		- streaming같은 경우 바뀌어도 지장이 없는데, 파일같은 경우 한 패킷이라도 없으면 복구가 안된다.
			- 같은 포트 번호를 사용했을 때 구분을 못하게 되면 문제가 발생하게 되는 것이다.
			- 소켓마다 버퍼들이 다 있는 거시다.
				- 이미 사용한 포트 번호를 반환하지 않고 살려둬서 문제를 해결할 수 있다.
				- 이게 TIME_WAIT상태다.
	- 같은 ip / 포트를 사용하는 새로운 커넥션이 생성되었을 때 문제가 발생하면 이를 해결할 수 없고, 따라서 TIME-WAIT상태를 설정하여 사용하는 것이다.
- 프로그램을 작성하고 close함수를 호출하지 않아도 자동으로 fin을 전송한다.
	- 이 3가지에 의해서 전송이 되는 것이다.
	- 서버는 항상 돌아가게 동작하는 것이 일반적이다.
	- 서버를 강제로 종료시켜도 FIN을 보내게 된다.
		- 다시 실행하면 bind error 뜬다.
			- 강제 종료 후에 TIME-WAIT상태로 동작하고 있기 때문이다.
			- 소켓을 만들 때 TIME-WAIT 상태로 들어가지 않는 서버도 만들 수 있다.
		- 따라서 상태에 대해 모두 이해할 수 있어야 한다.

### Denying a connection / Aborting a connection
- RST 패킷 보내서 커넥션 끊어버릴 수 있다.
![[C65E271B-855F-4389-BCDA-81DA5D47A7FF.jpeg]]

## Window in TCP
- 순차적으로 신호룰 주고 받는 것은 시간에서 비효율적이다.
	- 갔다가 응답 신호가 왔을때만 다음 신호를 보낼 수 있다.
	- 이러한 방식을 stop & wait 방식이라고 한다.
- 한번에 여러 개의 신호를 보내는 방식을 사용할 ㅅ ㅜ있다.
	- 한번에 얼만큼의 데이터를 보낼지 rule이 필요하다.
	- window size개념이라고 해서, 몇개를 한번에 보낼 것인지를 결정하고 그만큼만 보내게 된다.
	- 동시에 받을 수 있는 양을 알려주고, 그만큼만 데이터를 받도록 하여 문제를 해결할 수 있다.
- 데이터를 보내고 응답을 보낼 때 얼마나 받을 수 있을지를 보내어 문제를 해결할 수 있다.
- 이러한 데이터는 헤더의 Window Size에 담게 된다.
	- 남은 빈 공간을 여기에 명시하게 된다.
	- rwnd라고 표시하게 된다.
		- 패킷을 받을 수 있을 만큼만 보내주어야 한다.
		- 클라이언트도 ACK에 윈도우 사이즈를 명시하게 된다.
- 어플리케이션이 가져가는 속도에 따라 비워지는 속도가 달라지게 되고, 따라서 항상 비워지게 된다.
	- 처리하는 양이 많아 속도가 느려지게 되면 비워지는 속도도 느려지게 되어, 보낼 수 있는 패킷이 한정되게 된다.
- 패킷을 보내는 속도와 어플리케이션이 받는 속도가 대체로 싱크가 맞게 된다.

### rwnd / cwnd
- 서로 병렬적으로 작동한다.
	- 둘 중 작은것을 바탕으로 윈도우를 결정한다.
		- 왼쪽 벽은 상대방이 받은 것을 확인하면 그만큼 넘기게 된다.
		- 상대방이 받은 것을 확인하면 rwnd데이터로 잡게 된다.
### Flow Control
 write 함수는 블락함수이다.
	- 문제가 해결되면 반환되지만, 해결이 되지 않으면 block이 된다.
		- 데이터가 전송이 안되게 된다.
	- write를 보내면 또 빈공간을 보내게 되고, 따라서 return이 된다
		- 파일을 읽어올 때는, 네트워크 속도보다 빠르게 보내어 write가 이루어지게 된다.
		- 데이터를 버퍼에서 비워야만 데이터를 가져올 수 있게 된다.
		- 프로그램이 복잡해지면 이렇게 작동하지 않는다.
	- receiving buffer에서 read 함수를 부르면 데이터에 사라진다.
	- 비워지는 만큼 sender가 데이터를 보낼 수 있다.
		![[ACEAD03A-6D85-4684-9D69-62DDB89C63FE.jpeg]]
	- 따라서 1, 2, 3번의 속도가 맞춰진다.
- flow control은 데이터를 가져오고 비워지는 속도에 따라 sender의 어플리케이션에서 데이터를 전송하는 속도는 상대방이 데이터를 가져가는 속도에 맞춰지게 된다.

![[D1A4464D-F1A9-4732-B51B-FCAA441FFEC8.jpeg]]
- 들어온 데이터의 크기와 server에서의 window데이터를 확인해보면 된다.
	- 어플리케이션이 가져간 데이터만큼 window 사이즈가 증가하며, 들어온 데이터의 양만큼 window 사이즈가 감소하게 된다.
- 패킷을 보내려면 TCP / IP 헤더 40바이트는 항상 들어가게 된다.
	- 헤더는 데이터를 보내기 위한 오버헤드라고 할 수 있다.
	- 네트워크 입장에서는 이러한 데이터 전송이 오버헤드가 된다.
	- 따라서 이를 해결하기 위해 여러가지 알고리즘이 사용된다.

## Silly Window Syndrome
### Nagle Algorithm
- 보낼 데이터가 MSS로 정의된 크기만큼 쌓이면, 상대편에게 무조건 보낸다.
- 보낼 데이터가 MSS보다 작을 경우, 이전에 보낸 데이터에 대한 ACK가 올 떄 까지 기다린다.
	- ACK가 도달하면 보낼 데이터가 MSS보다 작더라도 상대에게 보낸다.
	- 데이터가 MSS를 채우면 그대로 전송하고,채우지 못하면 이를 확인하고 전송하지 않는다.
- Nagle이 없으면 데이터가 들어올 때마다 데이터를 전송하게 된다.

### Flow Control
- Stop-and-wait
	- 비효율적
	- 한번에 많이 보내고 싶어서, 상대방이 받을 수 있는 만큼 보내게 된다.
		- 상대방의 상황은 계속 변하고, 그렇기 때문에 window값에 포함하여 보내게 된다.
- Window 사이즈가 허락하면 계속 데이터를 보낼 수 있게 된다.
	- Packet 보내고 answer 안가면 사이즈가 너무 커지고 복잡해진다.
	- 상황에 따라 모두 달라지게 된다.
		- sender / receiver의 차이에 따라 달라지게 된다.
		- 보내는 중간에 ack 오는 등의 문제가 발생할 수 있다.
		- 상황마다 작동이 달라질 수 있게 되는 것이다.
- 알려진 window 사이즈에서 ack로 확인된 데이터를 제외하고 보낼 수 있는 데이터만 추가적으로 보내게 된다.
- flow control : sender는 전송 속도를 receiver의 어플리케이션이 데이터를 소비하는 속도와 맞게끔 전송 속도를 조절한다.
	- delay가 존재할 수 있고, 따라서 완전히 실시간으로 맞지 않고 보수적으로 접근한다.

## Silly Window Syndrome
- 헤더는 전송하는 데이터의 사이즈에 상관 없이 40바이트 차지한다.
	- 그럼 데이터가 40보다 작으면? 신난다
	- 이를 해결하는 방법으로 Nagle이 제한한 알고리즘을 사용하게 된다.
		- MSS 채워지면 바로 보내고, 안채워지면 ACK 올때까지 기다렸다 보내고.
	- 기다리는 최대시간만큼 기다리고 보내게 된다.
- 수신측에서도 이러한 문제가 발생할 수 있다.
	- 버퍼가 가득 차있을 때 어플리케이션 느리게 가져간다고 하자.
		- 가리켜준 데이터에 의해 데이터는 계속 오지만, 받을 수 있는 데이터 만큼만 보내게 된다.
	- 2가지 방법으로 해결할 수 있다.
		- Clark 해결방법
			- 패킷 하나의 크기가 찰 때 까지 / 버퍼의 절반이 비워질 때 까지 window 크기를 0으로 보내어 처리한 후 sender에서 데이터를 받아오도록 한다.
			- MSS만큼 비워지거나 버퍼의 절반이 비워지면 다시 데이터를 한번에 가져오는 것이다.
		- 일정 크기가 되기 전까지는 응답을 보내지 않는다.
			- ACK이 오지 않으면 window가 멈춰 있는다.
			- 리시버 입장에서는 데이터가 오는 것이 stop된다.
				- send를 stop시키는 것이라 할 수 있다.
			- 데이터가 바로 스탑되는 것이 아닌, 보낸 데이터를 받는데 걸리는 시간이 존재한다.
				- 빈 공간이 생성되었을 때 제대로된 데이터를 전송하게 된다.

## SYN Flooding
- Raw Socket으로 만들면 헤더를 직접 핸들링 할 수 있다.
	- ip 주소 / 포트 번호도 직접 작성할 수 있다.
	- 창 여러개 띄워서 계속 보내든 백그라운드로 돌리든 하는 방법으로 연결 요청을 대기하는 큐가 된다.
		- ACK이 올 때만 새로운 커넥션을 만들게 된다.
		- ACK이 오지 않으면 연결 요청은 큐에서 대기만 하게 된다.
	- 큐가 다 차면 SYN/ACK을 보낼 수 없게 된다.
		- SYN/ACK을 보내지 못하는 서비스 거부 상태하게 된다.
- 가짜 ip 주소로 변형하여 요청을 계속 보내어, ACK를 받지 못하도록 하여 서비스를 못하도록 하는 방법을 SYN Flooding이라 한다.
- 많은 위치에서 트래픽을 보내게 될 때. 정상적인 트래픽과 악의적인 트래픽이 동시에 들어올 때, 이를 파악할 수 없다. 
	- 이렇게 수행하는 공격을 Distribute Denial of Service라 한다.
- SYN Flooding은 초기의 방법이며, 서버가 처리하는 방법이 존재한다.
- 네트워크 프로토콜의 약점을 통해 공격을 할 수 있는 방법이 존재한다.
	- 네트워크 프로토콜 풀도 개선 되는 등의 발전이 이루어지고 있다.

- ACK에 대한 ACK은 존재하지 않는다.
	- 어떨땐 ACK 없어지면 대수롭지 않게 해결될 수 있으나, 어떤 ACK이 사라지면 Deadlock이 걸릴 수 있다.
	- 순차적으로 보냈을 때, 데이터를 다르게 받을 수 있다.
		- 같은 길로 가면 같은 순서로 가지만, 경로가 달라질 수 있다.
		- 대부분은 같은 경로로 간다.
- 어플리케이션에서 고민하지 않아도 된다.
- 데이터를 받으면 ACK을 보내는 것이 원칙.
		- ![[Pasted image 20220929171642.png]]
	- 헤더 안에 데이터를 포함하여 보낼 수 있다.
	- 따라서 보내는 데이터가 있으면 ACK에 같이 보낼 수 있다. 이를 통해 오버헤드를 줄일 수 있다.
		- 따라서 50ms의 대기 시간을 가져, 데이터를 기다린 후 ACK를 보내게 된다.
		- Rule 2가 된다.
	- 데이터를 일정 시간만큼 기다리고, 기다린 후 받은 데이터를 감안하여 ACK을 보내게 된다.
		- 이를 여러개 허용하지 않고, 2개 만큼만 허용하도록 하는 것이 Rule 3이다.
- 들어오던 데이터가 사라졌을 때 어떻게 처리해야 하는가?
	- ![[Pasted image 20220929171659.png]]
	- 순서가 바뀌거나 실종되는 등의 문제가 발생하면 50ms 기다리지 않고 데이터를 바로 요청하는 것이 Rule 4가 된다.
	- Sender는 패킷 보낼때 마다 타이밍을 저장한다.
		- 정해진 시간 내로 도착하지 않으면 데이터가 없어졌다고, 패킷 로스로 간주한다.
		- 이때 제대로 받은 데이터는 제외하고 로스된 데이터만 받는다. 이것이 Rule 5이다.
- 어플리케이션에는 정상적으로 처리된 데이터로만 보낸다.
	- 대부분의 프로그램은 TCP로 구성되게 된다.
- Packet loss는 timeout까지 대기를 한다.
	- Fast Retransmit![[Pasted image 20220929172345.png]]
	- 상황따라 다른데 window 사이즈가 가능하다면 가능한 만큼 보내게 된다.
	- 다른 데이터가 오더라도 못받은것을 계속 요청한다.
		- 중복된 ACK이 오면, 이를 패킷 로스로 간주하고 다시 보내도록 할 수 있다.
		- 다른 경로로 이동했을 수 있지만, 이를 로스로 간주한다.
	- 이러한 상황을 Fast Retransmit이라 한다.
		- 3개의 중복된 ACK이 들어오면 패킷 로스로 간주하고, Timeout 기다리지 않고 빠르게 확인하여 전송한다.
		- 직관적으로 3번의 ACK로 구현하도록 한 것이다.
### Lost Acknowledgment
- Lost Acknowledgement
	- ![[Pasted image 20220929172949.png]]
	- ACK이 로스 되었을 때, sender는 window 사이즈때문에 계속 데이터를 보낼 수 있다.
		- 서버에서는 정상이므로, ACK을 정상적으로 보내면, 클라이언트에서는 로스된 ACK이 정상적으로 전송되었다고 가정한다.
		- ACK이 로스되어도 문제 없이 데이터를 송/수신 할 수 있다.
- Lost Acknowledgment correct by reesending a segment
	- ![[Pasted image 20220929173009.png]]
	- 데이터를 정상적으로 받았지만 ACK가 loss가 타임아웃 상태까지 가면 바로 ACK을 보내어 새로 데이터를 받도록 한다.
- lost acknowledgement는 서로 기다리도록 하는 Deadlock 상태를 도달하도록 할 수 있다.
	- Timer를 사용하여 해결할 수 있다.
#### Timers
- Persistence Timer
	- 데드락 해결하기 위해 사용
	- 타이머가 만료되면, probe 세그먼트를 전송한다.
		- 소량의 데이터를 보내는 것을 probe라 한다.
			- 이를 통해 상대방의 상태를 확인하고, 교착 상태를 해결할 수 있다.
- Keepalive timer
	- 오랜 시간 idle 상태로 있는 것을 방지한다.
	- 서버가 2시간동안 클라이언트로부터 세그먼트를 전송받지 못하며 probe 세그먼트를 전송한다.
## Congestion Control
- Flow control -> 흐름 제어, Congestion Control -> 혼잡 제어
- 혼잡이라는 상황은 언제 발생하는가?
	- 입력의 대역폭이 출력의 대역폭보다 클 때 혼잡이 발생하게 된다.
		- 교통과 동일하다. 병목 구간이 발생하게 된다. bottleneck이라 한다.
- 보통 라우터 구조는 다음과 같이 구성된다
	- 아웃풋쪽에 버퍼가 있고, 순간적인 버스트는 버퍼가 흡수를 한다.
	- 지속적인 트래픽이 발생하여 버퍼보다 커지기 시작하면, 라우터는 패킷을 드랍한다.
		- 여러가지 이유가 발생하는데, 패킷을 버리는것은 핸들할 수 없는 상항에서 발생한다
			- 처리할 수 있는 방법이 없다.
- 다음과 같은 그래프로 로드와 딜레이의 관계를 알 수 있다.![[FF434A1F-BEFB-40EF-852B-29B96CF1228F.jpeg]]
	- Capacity에 접근할수록 딜레이가 급속도로 증가하게 된다.
		- 패킷이 사라지면 땡이 아니라 재전송이 되고, 이렇게 악순환이 반복되어 시간이 길어지게 된다.
- 기간 안에 받는 데이터 양은 다음과 같이 설명될 수 있다.![[64A16703-0999-4ABC-B322-C8483806400F.jpeg]]
	- 데이터를 받는 쪽을 많이 신경쓰게 된다.
		- 받는 쪽 입장에서 얼마나 걸리는지 생각해보면 좋다.
		- 단위로는 bps를 주로 사용한다.
	- 보내는 양을 늘리면, 받는 쪽도 throughput이 증가한다.
		- capacity를 넘어서면 throughput이 증가하게 되는 것이다.
		- packet loss가 발생하면 패킷을 재전송하게 된다.
			- 파일을 완성하는데 걸리는 시간이 증가하게 된다.
	- 네트워크를 어디서 운용하면 좋은가?
		- capacity를 넘어서면 안되고, 너무 낮은 로드를 주는 것도 별로다.
			- 적당한 로드를 주는 것이 중요하다.
- 인터넷의 트래픽이 관리될 수 있어야 한다.
	- 데이터는 receive가 받을 수 있을 만큼만 보낸다.
		- 현재 트래픽은 고려하지 않는다.
		- 만개의 데이터를 받을 수 있을 때, 네트워크를 보지 않고 상대방만 보는 것이다.
			- 새로운 커넥션이 들어올 때 마다 줄여줘야 한다.
			- 혼잡 제어는 TCP가 만들어진 후 추가된 것이다.
		- window는 그 순간의 받을 수 있는 min 사이즈를 갖고 데이터를 만든다.
			- 보통은 cwnd의 영향을 더 많이 받는다.
			- 바이트 단위로 많이 하는데, 그러면 설명이 너무 복잡해진다.
				- 그렇기 때문에 패킷 단위로 설명하게 된다.
- 패킷 하나의 크기를 Maximum Segment Size라 하는데, 패킷 단위로 보내게 된다.
	- cwnd가 4라는 의미는 4개의 패킷을 보내라는 의미이다.
	- 4개를 보내고, 4개 모두 ack가 왔으면 네트워크에 문제가 없다는 의미이다.
- 특정 서버로 접속을 할 때, 패킷이 없어지면 어떤 구간에서 없어졌는지 모른다.
	- 접속하는 최종 서버는 네트워크가 일반적으로 분리될 것이고, 데이터를 증가시켜가면서 전송해가면서 네트워크의 혼잡 상태를 확인하는 것이다
		- congestion avoidance라 한다.
		- 얼만큼 보내야 정상적으로 보낼수 있는지는 모른다.
			- 혼잡 가능 구간이 조온나게 많고 이걸 추적하는것도 좆같다.
		- 주기는 RTT마다 늘리는 것이다.
			- 갔다 와야 알기 때문에, 갔다 올때마다 보내는 것이다.
		- 전송하는 패킷을 하나씩 증가시키는 기법을 additive increase라 한다.
		- 전송하는 패킷을 두배씩 증가시키는을기법을 exponential increase라 한다.
			- slow start라고 할 수 있다.
			- 이러한 기법이 없을때는 상대방이 받을 수 있을 만큼 그대로 때려버렸는데, 이러한 congestion increase는 서서히 늘려가기 때문에 slow start라 한다.
			- 일반적으로 시스템에서 정의해둔 threshold만큼 exponential만큼 늘리고, 이후로는 additive increase로 처리한다.
				- 시스템에서 미리 정의하여 동작하기도 한다.
				- 네트워크가 혼잡이 될 수도 있고, 절대적인 기준은 아니다.
					- 그 이후에는 additive increase로 가는 것이다.
			- 정리하면 threshold 까지 exponential하게 증가하고, 이후 additive하게 증가한다.
				- 혼잡이 발생할 때 까지 additive하게 증가한다.
- 패킷 로스가 발생하면 이를 혼잡 상태의 발생으로 이해해도 된다.
	- 패킷 로스의 대부분이 혼잡 발생때문에 발생한다.
	- 패킷 로스가 발생하면 보내는 패킷 양을 반으로 줄인다.
		- 다시 additive increase로 간다.
- 다음과 같은 워크플로우를 따른다. ![[00BCC300-DAA7-4A2D-B3F7-9FBB6A0C788F.jpeg]]
- 다음과 같이 속도가 동작하는 것을 확인할 수 있다 ![[608D913B-60DD-4536-9258-2B7EECBC4470.jpeg]]
	- 16이 threshold라고 정해져 있다고 치고, 여기서부터는 additive increase로 보내는 것이다.
	- additive increase로 보내는 이유는, 라우터의 로드를 충분히 사용하기 위해서이다.
		- 제일 혼잡한 구간에 맞게끔 보내려고 하는 것이다.
		- 혼잡이 발생하면 이를 해결해주어야 한다.
			- 보내는 양을 줄여야 한다.
			- 모든 TCP 통신에서 동일하게 동작한다.
		- TCP는 우리가 하는것이 아닌, 패킷이 사용하는 것이다.
			- Sending Rate는 건드릴 수 없다.
- 여러개의 동시다발적인 패킷 로스가 발생하면 어떻게 될까?
	- 타임아웃이 발생하게 된다. 
		- 타임아웃을 통해 detect된 혼잡 상태를 심각한 혼잡 상태라고 한다.
		- 심각한 상황으로 간주하고, 1부터 다시 출발을 한다.
			- 이때 slow start로 가는 것이다.
			- 0으로 떨어지면 안된다.
		- 이때 타임아웃이 발생했으면 threshold도 감소하게 된다.
	- 윈도우 사이즈지만, sending rate와 동일하게 작동한다.
		- 일정 속도로 오는 것은 없다.
		- 다운로드 속도로 그래프 그리는 프로그램들 있는데 sampling으로 이렇게 보여주는 것이다.
			- RTT단위로 보면 계속 보내는 양이 변하게 되는 것이다.
- Connection의 Throughput으로 확인할 수 있다.![[D3FA2759-6C7F-45E7-A35C-254F9D210367.jpeg]]
- 2개의 합이 R보다 작으면 그래프 좌측 아래에 해당된다.
	- 우측 위는 혼잡 상태를 의미하게 된다.
	- 최초의 점이 이쪽에서 시작하게 되는 것이다.
	- 그림의 전제 조건은 connection 1 / 2의 RTT가 동일한 것이다.
		- Throughput은 10만큼 증가하게 된다.
		- 이 그림은 개념적인 것이다.
			- X가 증가한만큼 y도 동일한만큼 증가하게 된다.
			- 윈도우 사이즈는 현재 사이즈와 상관없이 RTT마다 증가하게 되는 것이다.
			- y = x라는 선과 평행하게 증가하게 된다.
				- 두개의 합이 R을 넘어가는 지점에서 혼잡이 발생하고, 이때 윈도우 사이즈를 반으로 줄이게 된다.
					- 오버된 지점에서 0점으로 선분을 긋고, 반이 되는 지점이 감소한 속도가 된다.
	- 혼잡 제어를 쓰면 데이터를 50 : 50으로 사용하게 된다.
		- RTT가 동일한 경우. TCP가 Fair한 이유를 개념적으로 설명할 수 있다.
		- 거리에 따라 / 회선의 속도에 따라 RTT가 다른데, 그래도 개념적으로는 이렇게 TCP가 Fair함을 설명할 수 있다.
			- 실제로 많이 보낸다고 해서 패킷 로스가 공평하게 일어나지는 않을 수도 없다.
			- 그래도 확률적으로 많이 보냈을 때 패킷 로스가 많이 발생할 확률이 높다.
				- 특이한 케이스가 있을 수는 있지만, 대체로 이렇게 구성된다.
	- TCP는 일정하게 가지 않는다.
		- 여러개의 패킷이 한번에 왔다가 가는 것이고, 그렇기 때문에 길게 봤을 때 위의 그래프로 이해하는 것이 큰 무리가 없다.
	- 중앙 통제 없이도 네트워크를 잘 사용할 수 있다.
- 혼잡이 왜 발생할까? 미리 다 정해져 예약된 것이 아니기 때문이다.
	- 인터넷은 중앙 통제가 아니기 때문에 이렇게 동작하지 않는다.
- Best-effort
	- 최선을 다한다는 말에는 보장되는 것이 없다는 것을 의미할 수 있다.
	- 인터넷에서 보장되는 것은 없다.
		- physical한 link의 capacity를 제공하고, 최선만 다 하는 것이다.
		- Circuit Switching Network는 보장이 된다.
			- 경로 셋업 과정을 중앙에서 미리 제어하고, 요구하는 Bandwidth를 보장시켜 주는 것이다.
			- 이렇게 경로가 설정되면 10분에 한대씩 시속 60km/s로 보장된다.
		- 보장이 안되면 연결 자체가 승인이 되지 않는다.
- 네트워크 관리하는 것들은 같은 편에 있지 못한다.
	- 퀄리티를 어느정도 보장할 수 있는가?
	- TCP는 네트워크 상황을 보면서 얼마나 보낼지를 결정한다.

- UDP는 혼잡 / 흐름 제어 없다.
	- 상황에 대해서 반영하지 않는다.
	- 특정 트래픽 이상이 오면 UDP를 막아버리기도 한다.
	- UDP / TCP 다르게 대역폭 설정하려면 IP 헤더에 쓰면 된다.

- 매개변수 타입 안 외워도 됨
	- 타입에 관한건 샘플 주어질 것. 다 알고는 있어야 함.
	- 멀티프로세스는 기말
- 시험공부는 깊고 어렵게
- 
