## loggerMiddleware
- Express에서는 Morgan을 이용해 로깅을 사용했다.
	- 이를 Nest.js에선 로거를 사용해 해결할 수 있다.
- Nest의 파일 작명법은 다음과 같다.
	- 이름.역할.ts
	- .이 파일에 많이 들어갈 수 있다.
		- DTO 만들때는 이름.response.dto.ts 이렇게 만들 것이다.
		- camel case보다 .을 많이 쓴다.
- 다음과 같이 express의 미들웨어를 정의할 수 있다.
	```ts
	export class LoggerMiddleware implements NestMiddleware {
    private logger = new Logger('http');

    use(request: Request, response: Response, next: NextFunction): void { ... }
	}
```
	- 익스프레스 미들웨어와 형식이 동일하고, 실제로 request, response, next도 express와 동일한 객체를 사용한다.
- this.logger.log라는 객체를 이용해 Logging을 수행한다.
	- context라는 것을 부여해준 것이고, 그게 아니면 Logger.log로 작성해도 되는 것이다.
	- console.log보다 이게 낫다.
	- console.log는 어떤 것과 연결되어 있는지 알기 어렵다.
		- 이러한 단점을 극복하기 위해 debug등의 패키지를 사용하여 로깅 위치를 찾는데, 이렇게 사용하면 자동으로 된다.
- 미들웨어 만들때 next 함수 꼭 실행시켜 줘야 한다.
	- 미들웨어 자체는 라우터보다 먼저 실행되어, 리퀘스트에 대한 기록을 진행한 후 라우터 끝날때 비동기로 실행한다.
- 실무에서는 Nest morgan 쓰세요 헛고생 하지 마시고.
	- 미들웨어 만들어보려고 만든거지 딱히 필요한건 아니다.

## implements
- implements를 쓰지 않아도 에러는 나지 않는다.
	- 근데 editor와 타입스크립트의 강점을 모두 활용할 수 있다.
	- 지정되어있는 모든 것을 구현해야 한다.
		- 실수로 작업하지 않은 내용들을 놓치지 않고 구현할 수 있도록 한다.
		- 오타 등의 문제가 생길 때 타입 검사를 하기 위해서 사용된다.

## injectable
- Injectable은 Provider들에 넣어줄 수 있어야 한다.
	- 앱 서비스에서 다른 서비스 쓰고 있으면, 넣어 주어야 한다.
- provider는 의존성 주입이라는 작업을 한다.
	- provider에 연결된 것을 보고 의존성 주입을 한다.
		- 따라서 이를 필요로 한다.
	- 하위 모델에 대해 필요한 의존성을 상위 컨트롤러에서 삽입해주는 것이다.
		- 앱 모듈에서 provider에 앱 서비스 넣어줬다.
			- 넣어준 것을 보고 Controller에서 이를 가져와 넣어줄 수 있는 것이다.
		- 재사용, 테스트 등에서 이점이 생긴다.
			- App controller에서 사용되는 앱 서비스를 다른 사람이 넣어주고, 재사용성이 높아질 수 있다.
- 매개변수를 바꿔주면 컨트롤러는 테스트에 있는 서비스를 가져오게 될 것이다.
	- 테스트할 때 편리하게 작동할 수 있다.
	- 정확한 비유는 아니지만, 의존성 주입이 구조에 있어서 매개변수의 역할을 할 수 있는 것이다.
- 함수가 고정이 되어 있으면, 고장된 지점 때문에 테스트가 어려워지게 된다.
	- 그래서 서비스에서 return을 사용하도록 하는 것이다.
	- 코드의 결합성을 낮추는 과정이라고 할 수 있다.
- 의존성 주입은 타입 적은 것 / provider 적힌 것 바탕으로 추론하게 된다.
- 프로그래밍에는 마법이 없다.
	- 의존성 주입에도 다 원인 / 원리가 있고, 그렇기 때문에 값이 들어가는 것이다.