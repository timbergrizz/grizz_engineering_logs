# TypeORM
- TypeORM은 Nest.js에서 사용되는 [[ORM]]이다.
- Sequelize에서 DB를 연결할 때 Sequelize-auto를 이용하여 자바스크립트 속성과 연동했다.
	- typeORM은 TypeORM-model-generator를 사용한다.
		- DB의 테이블을 참조하여 자바스크립트 객체형으로 만들어준다.
- Entity가 테이블에 대응되는 개념이라 할 수 있다.
- model-generator를 이용해 entity를 생성한 후, entity가 모델을 잘 표현하고 있는지 확인해야 한다.
	- 굳이 index같은건 확인할 필요 없다.
- ORM의 장점으로, 매핑이 되어 있으면 굳이 db의 속성 이름을 따라갈 필요 없이, 원하는대로 데이터를 설정하여 처리할 수 있다.
	- SQL과 자바스크립트의 표현법이 다르기 때문에, 이를 호환시키기 위해 유용하다.
- Entity 데코레이터를 빼고 보면 단순한 컬럼과 속성들이지만, Entity 데코레이터가 이를 완성시켜준다.
- Class로 생성되어서 좋은 점은, 겹치는 부분들은 상속을 통해 중복 제거를 할 수 있다.

## 관계 설정
- 객체 간의 관계를 설정하는 것이 중요하게 작용할 수 있다.
	- 슬랙 기준으로 workspace 하나가 여러개의 channel을 가질 수 있는 등의 관계가 발생하게 된다.
- decorator를 통해 이러한 관계를 표현할 수 있다.
	- 관계 설정할땐 반대에도 동일하게 생성해주어야 한다.
- Join 관계도 붙일 수 있는데, 일반적으로 Foreign Key가 속성으로 있는 곳에 붙인다.
	- one-to-many이면 many인 쪽에 붙여야 한다.
	- 슬랙 관계에서, 내 채널이 어떤 워크스테이션에 속하는지 명시할 수 있어야 한다.
	- 이렇게 연결하면, foreign key를 매개로 자동으로 join하여 작동한다.
- 반대로도 작동할 수 있다.
	- 상호간에 설정을 해두었기 때문에, 나누어진 채널에 따라 동작시킬 수 있다.
	- 관계 파악을 한 이후 데코레이터를 이용해 객체 간의 연결을 수행할 수 있다.

- ManyToMany같은 관계는 헷갈릴 수 있다.
	- 슬랙 기준 workspace와 user가 many to many 관계라 할 수 있다.
	- user는 여러개의 workspace에 들어갈 수 있고, workspace도 여러 명의 user를 수용할 수 있다.
	- many to many에서 버그 발생하면, one to many 여러개로 나누어 작동시켜도 된다.
- Join을 통해 중간 테이블이 발생할 수 있다.
	- JoinTable은 둘 중 하나에만 넣으면 된다.
	- many to many에서는 둘 중 하나에만 적당히 넣으면 된다.
- 관계들을 모두 설정하면 나중에 쿼리 날릴때 알아서 join해주고 편해진다.
- typeorm의 핵심은 column 설정의 간편함 등이다.
	- 조금 더 깔끔하게 TypeORM이 제공하는 기능들을 알고싶으면 공식 문서를 읽어 보면 좋다.
- soft delete등의 기능도 typeorm에서 지원된다.

- 한번에 여러 테이블을 수정하는건 위험하다.
	- 지원은 되는데, cascade를 통해 작동시켜야 한다.
- JPA와 거의 동일하게 작동한다.
- Entity에 Swagger 같이 넣으면 표현까지 잘 뽑힌다.
- Nest가 entity 자체를 DTO로 인식해준다.

- 놀랍게도 CRUD 자동으로 만들어주는 것도 존재한다.
	- co 하면 resource로 서비스까지 다 만들어준다.
	- Nest 도큐멘테이션 예제가 없어서 아쉬운거 빼면 다 .
- typeorm 연결하는건 공식문서 보고 잘 따라하면 된다. [공식 문서](https://docs.nestjs.com/recipes/sql-typeorm)
	- 상황에 맞게 변형해서 써야 한다. 드라이버같은거 제대로 설치해야 한다.
- 다음과 같이 TypeOrmModule을 import하여 사용할 수 있다. ![[Screenshot 2022-10-09 at 1.34.26.png]]
	- 이때 synchronize는 처음에만 수행하고 지워줘야 한다.
	- 또한, entity를 자동으로 인식하여 가져올 수도 있는데, 이것도 가끔 삑난다.
		- 폴더 단위로도 불러와지니까 이렇게 하는게 제일 무난할 것 같다.
- ```orm.config.ts```를 따로 만드는 것도 하나의 방법이다.
- ORM은 데이터가 복잡해질수록 비효율적인 코드를 짤 확률이 높아진다.
	- 개발할때는 무조건 로그 켜놓는 편이 좋다.
	- ORM이 어떤 테이블로 쿼리 날리는지 분석하고 튜닝하는 것이 좋다.
- orm.config.ts가 루트 디렉토리에 있는데, 이거 다른데 있으면 마이그레이션에서 오류 나서 저기 넣어둔거다.

- 로우 쿼리를 날려야 할 필요도 있는데, 이때는 그냥 찾아서 원하는 방법으로 날리면 된다.
	- active repository도 있다는 것 알아두면 좋다.
- ConfigModule을 이용해 .env 갖고와서 작동시키려면 다음과 같이 Module import를 수정하면 된다.![[Screenshot 2022-10-09 at 1.41.15.png]]
	- ConfigService에 대한 Inject가 이루어진 후, ConfigService를 사용할 수 있을 때 .env를 가져오도록 할 수 있다.
		- 우리가 환경 변수를 로컬이 아닌 다른 외부 비밀 저장소에 저장하는 케이스가 더 많고, 따라서 이렇게 비동기적으로 데이터 가져와서 사용하는 케이스가 더 많을 것이다.

## Seeding / Migration
